// Code generated by mockery v1.0.0
package impl

import db "nebula-tracker/db"

import mock "github.com/stretchr/testify/mock"
import rsa "crypto/rsa"
import time "time"

// daoMock is an autogenerated mock type for the daoMock type
type daoMock struct {
	mock.Mock
}

// ClientGetPubKey provides a mock function with given fields: nodeId
func (_m *daoMock) ClientGetPubKey(nodeId string) *rsa.PublicKey {
	ret := _m.Called(nodeId)

	var r0 *rsa.PublicKey
	if rf, ok := ret.Get(0).(func(string) *rsa.PublicKey); ok {
		r0 = rf(nodeId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rsa.PublicKey)
		}
	}

	return r0
}

// FileCheckExist provides a mock function with given fields: nodeId, hash, spaceNo, doneExpSecs
func (_m *daoMock) FileCheckExist(nodeId string, hash string, spaceNo uint32, doneExpSecs int) ([]byte, bool, bool, string, uint64, bool, bool) {
	ret := _m.Called(nodeId, hash, spaceNo, doneExpSecs)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string, string, uint32, int) []byte); ok {
		r0 = rf(nodeId, hash, spaceNo, doneExpSecs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(string, string, uint32, int) bool); ok {
		r1 = rf(nodeId, hash, spaceNo, doneExpSecs)
	} else {
		r1 = ret.Get(1).(bool)
	}

	var r2 bool
	if rf, ok := ret.Get(2).(func(string, string, uint32, int) bool); ok {
		r2 = rf(nodeId, hash, spaceNo, doneExpSecs)
	} else {
		r2 = ret.Get(2).(bool)
	}

	var r3 string
	if rf, ok := ret.Get(3).(func(string, string, uint32, int) string); ok {
		r3 = rf(nodeId, hash, spaceNo, doneExpSecs)
	} else {
		r3 = ret.Get(3).(string)
	}

	var r4 uint64
	if rf, ok := ret.Get(4).(func(string, string, uint32, int) uint64); ok {
		r4 = rf(nodeId, hash, spaceNo, doneExpSecs)
	} else {
		r4 = ret.Get(4).(uint64)
	}

	var r5 bool
	if rf, ok := ret.Get(5).(func(string, string, uint32, int) bool); ok {
		r5 = rf(nodeId, hash, spaceNo, doneExpSecs)
	} else {
		r5 = ret.Get(5).(bool)
	}

	var r6 bool
	if rf, ok := ret.Get(6).(func(string, string, uint32, int) bool); ok {
		r6 = rf(nodeId, hash, spaceNo, doneExpSecs)
	} else {
		r6 = ret.Get(6).(bool)
	}

	return r0, r1, r2, r3, r4, r5, r6
}

// FileOwnerCheckId provides a mock function with given fields: id, spaceNo
func (_m *daoMock) FileOwnerCheckId(id []byte, spaceNo uint32) (string, []byte, bool) {
	ret := _m.Called(id, spaceNo)

	var r0 string
	if rf, ok := ret.Get(0).(func([]byte, uint32) string); ok {
		r0 = rf(id, spaceNo)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 []byte
	if rf, ok := ret.Get(1).(func([]byte, uint32) []byte); ok {
		r1 = rf(id, spaceNo)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	var r2 bool
	if rf, ok := ret.Get(2).(func([]byte, uint32) bool); ok {
		r2 = rf(id, spaceNo)
	} else {
		r2 = ret.Get(2).(bool)
	}

	return r0, r1, r2
}

// FileOwnerFileExists provides a mock function with given fields: nodeId, spaceNo, parent, name
func (_m *daoMock) FileOwnerFileExists(nodeId string, spaceNo uint32, parent []byte, name string) ([]byte, bool, string) {
	ret := _m.Called(nodeId, spaceNo, parent, name)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string, uint32, []byte, string) []byte); ok {
		r0 = rf(nodeId, spaceNo, parent, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(string, uint32, []byte, string) bool); ok {
		r1 = rf(nodeId, spaceNo, parent, name)
	} else {
		r1 = ret.Get(1).(bool)
	}

	var r2 string
	if rf, ok := ret.Get(2).(func(string, uint32, []byte, string) string); ok {
		r2 = rf(nodeId, spaceNo, parent, name)
	} else {
		r2 = ret.Get(2).(string)
	}

	return r0, r1, r2
}

// FileOwnerIdOfFilePath provides a mock function with given fields: nodeId, path, spaceNo
func (_m *daoMock) FileOwnerIdOfFilePath(nodeId string, path string, spaceNo uint32) (bool, []byte, []byte, bool) {
	ret := _m.Called(nodeId, path, spaceNo)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string, uint32) bool); ok {
		r0 = rf(nodeId, path, spaceNo)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 []byte
	if rf, ok := ret.Get(1).(func(string, string, uint32) []byte); ok {
		r1 = rf(nodeId, path, spaceNo)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	var r2 []byte
	if rf, ok := ret.Get(2).(func(string, string, uint32) []byte); ok {
		r2 = rf(nodeId, path, spaceNo)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]byte)
		}
	}

	var r3 bool
	if rf, ok := ret.Get(3).(func(string, string, uint32) bool); ok {
		r3 = rf(nodeId, path, spaceNo)
	} else {
		r3 = ret.Get(3).(bool)
	}

	return r0, r1, r2, r3
}

// FileOwnerListOfPath provides a mock function with given fields: nodeId, spaceNo, parentId, pageSize, pageNum, sortField, asc
func (_m *daoMock) FileOwnerListOfPath(nodeId string, spaceNo uint32, parentId []byte, pageSize uint32, pageNum uint32, sortField string, asc bool) (uint32, []*db.Fof) {
	ret := _m.Called(nodeId, spaceNo, parentId, pageSize, pageNum, sortField, asc)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(string, uint32, []byte, uint32, uint32, string, bool) uint32); ok {
		r0 = rf(nodeId, spaceNo, parentId, pageSize, pageNum, sortField, asc)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 []*db.Fof
	if rf, ok := ret.Get(1).(func(string, uint32, []byte, uint32, uint32, string, bool) []*db.Fof); ok {
		r1 = rf(nodeId, spaceNo, parentId, pageSize, pageNum, sortField, asc)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*db.Fof)
		}
	}

	return r0, r1
}

// FileOwnerMkFolders provides a mock function with given fields: interactive, nodeId, spaceNo, parent, folders
func (_m *daoMock) FileOwnerMkFolders(interactive bool, nodeId string, spaceNo uint32, parent []byte, folders []string) ([]string, []string) {
	ret := _m.Called(interactive, nodeId, spaceNo, parent, folders)

	var r0 []string
	if rf, ok := ret.Get(0).(func(bool, string, uint32, []byte, []string) []string); ok {
		r0 = rf(interactive, nodeId, spaceNo, parent, folders)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 []string
	if rf, ok := ret.Get(1).(func(bool, string, uint32, []byte, []string) []string); ok {
		r1 = rf(interactive, nodeId, spaceNo, parent, folders)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}

	return r0, r1
}

// FileOwnerMove provides a mock function with given fields: nodeId, id, spaceNo, newId
func (_m *daoMock) FileOwnerMove(nodeId string, id []byte, spaceNo uint32, newId []byte) {
	_m.Called(nodeId, id, spaceNo, newId)
}

// FileOwnerRemove provides a mock function with given fields: nodeId, spaceNo, pathId, recursive
func (_m *daoMock) FileOwnerRemove(nodeId string, spaceNo uint32, pathId []byte, recursive bool) bool {
	ret := _m.Called(nodeId, spaceNo, pathId, recursive)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, uint32, []byte, bool) bool); ok {
		r0 = rf(nodeId, spaceNo, pathId, recursive)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FileOwnerRename provides a mock function with given fields: nodeId, id, spaceNo, newName
func (_m *daoMock) FileOwnerRename(nodeId string, id []byte, spaceNo uint32, newName string) {
	_m.Called(nodeId, id, spaceNo, newName)
}

// FileRetrieve provides a mock function with given fields: nodeId, hash, spaceNo
func (_m *daoMock) FileRetrieve(nodeId string, hash string, spaceNo uint32) (bool, bool, []byte, int, []string, uint64, string, []byte) {
	ret := _m.Called(nodeId, hash, spaceNo)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string, uint32) bool); ok {
		r0 = rf(nodeId, hash, spaceNo)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(string, string, uint32) bool); ok {
		r1 = rf(nodeId, hash, spaceNo)
	} else {
		r1 = ret.Get(1).(bool)
	}

	var r2 []byte
	if rf, ok := ret.Get(2).(func(string, string, uint32) []byte); ok {
		r2 = rf(nodeId, hash, spaceNo)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]byte)
		}
	}

	var r3 int
	if rf, ok := ret.Get(3).(func(string, string, uint32) int); ok {
		r3 = rf(nodeId, hash, spaceNo)
	} else {
		r3 = ret.Get(3).(int)
	}

	var r4 []string
	if rf, ok := ret.Get(4).(func(string, string, uint32) []string); ok {
		r4 = rf(nodeId, hash, spaceNo)
	} else {
		if ret.Get(4) != nil {
			r4 = ret.Get(4).([]string)
		}
	}

	var r5 uint64
	if rf, ok := ret.Get(5).(func(string, string, uint32) uint64); ok {
		r5 = rf(nodeId, hash, spaceNo)
	} else {
		r5 = ret.Get(5).(uint64)
	}

	var r6 string
	if rf, ok := ret.Get(6).(func(string, string, uint32) string); ok {
		r6 = rf(nodeId, hash, spaceNo)
	} else {
		r6 = ret.Get(6).(string)
	}

	var r7 []byte
	if rf, ok := ret.Get(7).(func(string, string, uint32) []byte); ok {
		r7 = rf(nodeId, hash, spaceNo)
	} else {
		if ret.Get(7) != nil {
			r7 = ret.Get(7).([]byte)
		}
	}

	return r0, r1, r2, r3, r4, r5, r6, r7
}

// FileReuse provides a mock function with given fields: existId, nodeId, id, hash, name, size, modTime, spaceNo, parentId, fileType
func (_m *daoMock) FileReuse(existId []byte, nodeId string, id []byte, hash string, name string, size uint64, modTime uint64, spaceNo uint32, parentId []byte, fileType string) {
	_m.Called(existId, nodeId, id, hash, name, size, modTime, spaceNo, parentId, fileType)
}

// FileSaveDone provides a mock function with given fields: existId, nodeId, hash, name, fileType, size, modTime, spaceNo, parentId, partitionCount, blocks, storeVolume, encryptKey
func (_m *daoMock) FileSaveDone(existId []byte, nodeId string, hash string, name string, fileType string, size uint64, modTime uint64, spaceNo uint32, parentId []byte, partitionCount int, blocks []string, storeVolume uint64, encryptKey []byte) {
	_m.Called(existId, nodeId, hash, name, fileType, size, modTime, spaceNo, parentId, partitionCount, blocks, storeVolume, encryptKey)
}

// FileSaveStep1 provides a mock function with given fields: nodeId, hash, fileType, size, storeVolume, spaceNo
func (_m *daoMock) FileSaveStep1(nodeId string, hash string, fileType string, size uint64, storeVolume uint64, spaceNo uint32) {
	_m.Called(nodeId, hash, fileType, size, storeVolume, spaceNo)
}

// FileSaveTiny provides a mock function with given fields: existId, nodeId, hash, fileData, name, size, modTime, spaceNo, parentId, fileType, encryptKey
func (_m *daoMock) FileSaveTiny(existId []byte, nodeId string, hash string, fileData []byte, name string, size uint64, modTime uint64, spaceNo uint32, parentId []byte, fileType string, encryptKey []byte) {
	_m.Called(existId, nodeId, hash, fileData, name, size, modTime, spaceNo, parentId, fileType, encryptKey)
}

// ProviderFindOne provides a mock function with given fields: nodeId
func (_m *daoMock) ProviderFindOne(nodeId string) *db.ProviderInfo {
	ret := _m.Called(nodeId)

	var r0 *db.ProviderInfo
	if rf, ok := ret.Get(0).(func(string) *db.ProviderInfo); ok {
		r0 = rf(nodeId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.ProviderInfo)
		}
	}

	return r0
}

// UsageAmount provides a mock function with given fields: nodeId
func (_m *daoMock) UsageAmount(nodeId string) (bool, bool, int64, uint32, uint32, uint32, uint32, uint32, uint32, uint32, uint32, time.Time) {
	ret := _m.Called(nodeId)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(nodeId)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(nodeId)
	} else {
		r1 = ret.Get(1).(bool)
	}

	var r2 int64
	if rf, ok := ret.Get(2).(func(string) int64); ok {
		r2 = rf(nodeId)
	} else {
		r2 = ret.Get(2).(int64)
	}

	var r3 uint32
	if rf, ok := ret.Get(3).(func(string) uint32); ok {
		r3 = rf(nodeId)
	} else {
		r3 = ret.Get(3).(uint32)
	}

	var r4 uint32
	if rf, ok := ret.Get(4).(func(string) uint32); ok {
		r4 = rf(nodeId)
	} else {
		r4 = ret.Get(4).(uint32)
	}

	var r5 uint32
	if rf, ok := ret.Get(5).(func(string) uint32); ok {
		r5 = rf(nodeId)
	} else {
		r5 = ret.Get(5).(uint32)
	}

	var r6 uint32
	if rf, ok := ret.Get(6).(func(string) uint32); ok {
		r6 = rf(nodeId)
	} else {
		r6 = ret.Get(6).(uint32)
	}

	var r7 uint32
	if rf, ok := ret.Get(7).(func(string) uint32); ok {
		r7 = rf(nodeId)
	} else {
		r7 = ret.Get(7).(uint32)
	}

	var r8 uint32
	if rf, ok := ret.Get(8).(func(string) uint32); ok {
		r8 = rf(nodeId)
	} else {
		r8 = ret.Get(8).(uint32)
	}

	var r9 uint32
	if rf, ok := ret.Get(9).(func(string) uint32); ok {
		r9 = rf(nodeId)
	} else {
		r9 = ret.Get(9).(uint32)
	}

	var r10 uint32
	if rf, ok := ret.Get(10).(func(string) uint32); ok {
		r10 = rf(nodeId)
	} else {
		r10 = ret.Get(10).(uint32)
	}

	var r11 time.Time
	if rf, ok := ret.Get(11).(func(string) time.Time); ok {
		r11 = rf(nodeId)
	} else {
		r11 = ret.Get(11).(time.Time)
	}

	return r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11
}
